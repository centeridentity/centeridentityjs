export default class CenterIdentity {
    constructor(kwargs: any);
    strength: number;
    api_key: any;
    url_prefix: any;
    use_local_storage: any;
    friends_list_wif: string;
    origin: string;
    selfGenerateTransaction: any;
    precision: any;
    createRelationship(me: any, user: any, extra_data: any): Promise<any>;
    createRelationshipTransaction(me: any, user: any, group: any, extra_data: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    }>;
    approveRelationshipTransaction(me: any, user: any, request: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    }>;
    createRelationshipFromNew(me: any, name: any, extra_data: any): Promise<any>;
    set(user: any, latitude: any, longitude: any): Promise<any>;
    setFromNew(username: any, latitude: any, longitude: any): Promise<any>;
    username: any;
    latitude: any;
    longitude: any;
    setV2(user: any, entropy: any): Promise<any>;
    setFromNewV2(username: any, entropy: any): Promise<any>;
    entropy: any;
    setAsset(username: any, latitude: any, longitude: any, asset: any): Promise<any>;
    getAsset(username: any, latitude: any, longitude: any): Promise<any>;
    get(username: any, latitude: any, longitude: any): Promise<any>;
    getV2(username: any, entropy: any): Promise<any>;
    getLocation(): Promise<any>;
    showPosition(username: any, position: any): Promise<any>;
    showPositionV2(entropy: any): Promise<any>;
    generateRecovery(): Promise<any>;
    symmetric_key: string;
    rid: string;
    encryptSeed(seed: any): Promise<any>;
    encrypt(keyStr: any, message: any): any;
    decryptSeed(): Promise<any>;
    decrypt(keyStr: any, message: any): string;
    createUser(username: any): Promise<any>;
    reviveUser(wif: any, username: any): Promise<any>;
    sign(message: any, user: any): Promise<any>;
    verify(message: any, user: any, signature: any): any;
    toWif(private_key: any): any;
    fromWif(wif: any): string;
    verifyIssuedCredential(issuer: any, message: any, issuer_signature: any): any;
    verifySubjectRequestedCredential(subject: any, message: any, subject_signature: any): any;
    verifyVerifierRequestedCredential(verifier: any, message: any, verifier_signature: any): any;
    signSession(session_id: any, user: any): Promise<any>;
    signIn(session_id: any, user: any, signin_url: any): Promise<any>;
    signInWithLocation(session_id_url: any, private_username: any, public_username: any, lat: any, long: any, signin_url: any): Promise<Response>;
    registerWithLocation(session_id_url: any, private_username: any, public_username: any, lat: any, long: any, other_args: any, register_url: any): Promise<Response>;
    addUser(user: any, url?: any): Promise<void>;
    getUser(user: any, url?: any): Promise<void>;
    get_dh_keys(me: any, them: any): {
        dh_private_key: string;
        dh_public_key: string;
    };
    getSharedSecret(me: any, them: any, their_txn: any): string;
    authenticate(challenge_url?: string): Promise<{
        api_key: any;
        challenge: any;
        identity: {
            username: any;
            username_signature: any;
            public_key: any;
        };
    }>;
    generate_username_signature(key: any, username: any): Promise<any>;
    getAddress(pubKey: any): Promise<any>;
    arbuf2hex(buffer: any): Promise<string>;
    sha256(hexstr: any): Promise<string>;
    toHex(byteArray: any): string;
    hexToBytes(s: any): string;
    hexToByteArray(s: any): Uint8Array;
    generate_rid(user1: any, user2: any, extra_data?: string): any;
    generateTransaction(user: any, public_key: any, dh_public_key: any, rid: any, relationship: any, fee: any, requester_rid: any, requested_rid: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    }>;
    theirIdentityFromTransaction(txn: any, their_txn: any): {
        username: any;
        username_signature: any;
        public_key: any;
        dh_private_key: any;
    };
    theirIdentityFromEncryptedTransaction(me: any, txn: any, their_txn: any): {
        username: any;
        username_signature: any;
        public_key: any;
        dh_private_key: any;
    };
    myIdentityFromTransaction(txn: any): {
        username: any;
        username_signature: any;
        public_key: any;
    };
    messageFromEncryptedTransaction(me: any, them: any, their_txn: any, txn: any): any;
    generateGroupMessageTransaction(me: any, them: any, group: any, message: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    }>;
    generatePrivateMessageTransaction(me: any, them: any, their_txn: any, message: any, collection: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    }>;
    getTransactionsByRid(rid: any): Promise<Response>;
    getTransactionsByRequestedRid(rid: any): Promise<Response>;
    getTransactionsByRequesterRid(rid: any): Promise<Response>;
    getRelationshipTransactions(me: any, them: any, collection: any): Promise<void | {
        mine: string;
        theirs: string;
    }>;
    getIdentitiesByCollection(me: any, collection: any, friendList: any): Promise<any>;
    getDataByCollection(me: any, collection: any, friendList: any): Promise<any>;
    getFriendsLists(me: any, listName: any): Promise<Response>;
    getFriendsList(me: any, listName: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    } | {
        username: any;
        username_signature: any;
        public_key: any;
        dh_private_key: any;
    }>;
    setFriendsList(me: any, listName: any): Promise<{
        rid: any;
        fee: any;
        dh_public_key: any;
        requester_rid: any;
        requested_rid: any;
        outputs: any[];
        inputs: any[];
        time: string;
        public_key: any;
        relationship: any;
    }>;
    getPrivateMessages(me: any, them: any, collection: any, filter: any): Promise<any[]>;
    sendPrivateMessage(me: any, them: any, collection: any, message: any): Promise<any>;
    issueCredential(me: any, them: any, credential: any, credentialMessage: any): Promise<{
        transaction: any;
        message: string;
    }>;
    getCredentialsIssued(me: any, them: any, credential: any): Promise<any[]>;
    getCredentialsRequested(me: any, them: any, credential: any): Promise<any[]>;
    requestCredentialFromIssuer(me: any, issuer: any, credential: any): Promise<any>;
    requestCredentialThroughSubject(me: any, issuer: any, subject: any, credential: any): Promise<any>;
    forwardIssuedCredential(me: any, issuer: any, verifier: any, credential: any): Promise<any>;
    forwardRequestedCredential(me: any, issuer: any, verifier: any, credential: any): Promise<any>;
    getIdentityLink(identity: any): Promise<any>;
    getCredentialLink(credential: any): Promise<any>;
    connectIdentities(me: any, them: any, friendList: any, collection: any, extra_data: any): Promise<any>;
    addCredential(me: any, credential: any, friendList: any, collection: any): Promise<void>;
    importConnectionFromSkylink(me: any, skylink: any, collection: any, friendList: any, extra_data: any): Promise<any>;
    addHttp(url: any): any;
    signOut(): Promise<void>;
    copy(data: any): any;
    toObject(user: any): {
        username: any;
        username_signature: any;
        public_key: any;
    };
    toJson(user: any): string;
}
